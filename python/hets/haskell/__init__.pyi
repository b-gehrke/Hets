from typing import Any, Tuple, TypeVar, Generic, List, Callable

from .OMap import OMap

A = TypeVar("A")
B = TypeVar("B")
C = TypeVar("C")


#### Prelude ####

class Maybe(Generic[A]): ...


class Just(Maybe[A]):
    def __init__(self, x: A): ...

class Nothing(Maybe[A]):
    def __init__(self): ...

class IO(Generic[A]):
    def act(self) -> A: ...


def show(x: Any) -> str: ...


def fst(tuple: Tuple[A, B]) -> A: ...


def snd(tuple: Tuple[A, B]) -> B: ...


#### Internal ####



class Result(Generic[A]):
    def diags(self) -> List[Any]: ...


def resultToMaybe(r: Result[A]) -> Maybe[A]: ...

class Conservativity: ...

class ConsStatus:
    def isProvenConsStatusLink(self) -> bool: ...

    def requiredConservativity(self) -> Conservativity: ...

    def provenConservativity(self) -> Conservativity: ...

    ...

def showConsistencyStatus(c: Conservativity) -> str: ...

class ProofState: ...

#### HetsAPI.Python


def fstOf3(tuple: Tuple[A, B, C]) -> A: ...


def sndOf3(tuple: Tuple[A, B, C]) -> B: ...


def thd(tuple: Tuple[A, B, C]) -> C: ...


TheoryPointer = Tuple[Any, Any, Any, Any]


class PyTheory: ...


class PyProver: ...


class PyConsChecker: ...


class PyComorphism: ...


class PyProofOptions:
    def __init__(self, proofOptsProver: Maybe[PyProver],
                 proofOptsComorphism: Maybe[PyComorphism],
                 proofOptsUseTheorems: bool,
                 proofOptsGoalsToProve: List[str],
                 proofOptsAxiomsToInclude: List[str],
                 proofOptsTimeout: int): ...

    def proofOptsProver(self) -> Maybe[PyProver]: ...

    def proofOptsComorphism(self) -> Maybe[PyComorphism]: ...

    def proofOptsUseTheorems(self) -> bool: ...

    def proofOptsGoalsToProve(self) -> List[str]: ...

    def proofOptsAxiomsToInclude(self) -> List[str]: ...

    def proofOptsTimeout(self) -> int: ...

defaultProofOptions: PyProofOptions = ...

def mkPyProofOptions(proofOptsProver: Maybe[PyProver],
                 proofOptsComorphism: Maybe[PyComorphism],
                 proofOptsUseTheorems: bool,
                 proofOptsGoalsToProve: List[str],
                 proofOptsAxiomsToInclude: List[str],
                 proofOptsTimeout: int) -> PyProofOptions: ...

class PyConsCheckingOptions:
    def __init__(self,
                 consOptsConsChecker: Maybe[PyConsChecker],
                 consOptsComorphism: Maybe[PyComorphism],
                 consOptsIncludeTheorems: bool,
                 consOptsTimeout: int): ...

    def consOptsConsChecker(self) -> Maybe[PyConsChecker]: ...

    def consOptsComorphism(self) -> Maybe[PyComorphism]: ...

    def consOptsIncludeTheorems(self) -> bool: ...

    def consOptsTimeout(self) -> int: ...

defaultConsCheckingOptions: PyConsCheckingOptions = ...

def getDGNodeById(g: DGraph, id: int) -> Maybe[DGNodeLab]: ...

class Sentence: ...


class HetcatsOpts: ...


class DGraph: ...


class DGNodeLab:
    def dgn_name(self) -> str: ...

    def getNodeConsStatus(self) -> ConsStatus: ...

    ...


class Diagnosis: ...


class PyProofTree: ...


class GoalStatus: ...


class TimeOfDay: ...


class TacticScript: ...


class ProofStatus(Generic[A]):
    def goalName(self) -> str: ...

    def goalStatus(self) -> GoalStatus: ...

    def usedAxioms(self) -> List[str]: ...

    def usedProver(self) -> str: ...

    def proofTree(self) -> A: ...

    def usedTime(self) -> TimeOfDay: ...

    def tacticScript(self) -> TacticScript: ...

    def proofLines(self) -> List[str]: ...


class ConsistencyStatus: ...


def proveNodeAndRecord(theoryPointer: TheoryPointer, options: PyProofOptions) -> IO[
    Result[Tuple[Tuple[PyTheory, List[ProofStatus[PyProofTree]]], LibEnv]]]: ...


def checkConsistencyAndRecord(theoryPointer: TheoryPointer, options: PyConsCheckingOptions) -> IO[
    Tuple[ConsistencyStatus, LibEnv]]: ...


def availableComorphisms(t: PyTheory) -> List[PyComorphism]: ...


def getLNodesFromDevelopmentGraph(g: DGraph) -> List[Tuple[int, DGNodeLab]]: ...


def getTheoryFromNode(n: DGNodeLab) -> PyTheory: ...


def usableConsistencyCheckers(t: PyTheory) -> IO[List[Tuple[PyConsChecker, PyComorphism]]]: ...


def usableProvers(t: PyTheory) -> IO[List[Tuple[PyProver, PyComorphism]]]: ...


def prettySentence(t: PyTheory) -> Callable[[Sentence], str]: ...


def getAllSentences(t: PyTheory) -> OMap[str, Sentence]: ...


def getAllAxioms(t: PyTheory) -> OMap[str, Sentence]: ...


def getAllGoals(t: PyTheory) -> OMap[str, Sentence]: ...


def getProvenGoals(t: PyTheory) -> OMap[str, Sentence]: ...


def getUnprovenGoals(t: PyTheory) -> OMap[str, Sentence]: ...


def getProverName(p: PyProver) -> str: ...


def getComorphismName(c: PyComorphism) -> str: ...


def getConsCheckerName(c: PyConsChecker) -> str: ...


def loadLibrary(path: str, opts: HetcatsOpts) -> IO[Result[Tuple[LibName, LibEnv]]]: ...


def getGraphForLibrary(n: LibName, e: LibEnv) -> DGraph: ...


def resultToMaybe() -> Any: ...


def defaultHetcatsOpts() -> HetcatsOpts: ...


def fromJust(m: Maybe[A]) -> A: ...


# Library
class LibName: ...


class LibEnv: ...


def automatic(name: LibName, env: LibEnv) -> LibEnv: ...


def globalSubsume(name: LibName, env: LibEnv) -> LibEnv: ...


def globalDecomposition(name: LibName, env: LibEnv) -> LibEnv: ...


def localInference(name: LibName, env: LibEnv) -> LibEnv: ...


def localDecomposition(name: LibName, env: LibEnv) -> LibEnv: ...


def compositionProveEdges(name: LibName, env: LibEnv) -> LibEnv: ...


def conservativity(name: LibName, env: LibEnv) -> LibEnv: ...


def automaticHideTheoremShift(name: LibName, env: LibEnv) -> LibEnv: ...


def theoremHideShift(name: LibName, env: LibEnv) -> LibEnv: ...


def computeColimit(name: LibName, env: LibEnv) -> LibEnv: ...


def normalForm(name: LibName, env: LibEnv) -> LibEnv: ...


def triangleCons(name: LibName, env: LibEnv) -> LibEnv: ...


def freeness(name: LibName, env: LibEnv) -> LibEnv: ...


def libFlatImports(name: LibName, env: LibEnv) -> LibEnv: ...


def libFlatDUnions(name: LibName, env: LibEnv) -> LibEnv: ...


def libFlatRenamings(name: LibName, env: LibEnv) -> LibEnv: ...


def libFlatHiding(name: LibName, env: LibEnv) -> LibEnv: ...


def libFlatHeterogen(name: LibName, env: LibEnv) -> LibEnv: ...


def qualifyLibEnv(name: LibName, env: LibEnv) -> LibEnv: ...

def getGlobalTheory(node: DGNodeLab) -> PyTheory: ...

def recomputeNode(thPtr: TheoryPointer) -> LibEnv: ...
