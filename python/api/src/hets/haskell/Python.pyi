""" Auto generated python stubs for haskell module HetsAPI.Python"""

import typing

from .custom import *
from .Prelude import *
from .Internal import *
from .OMap import *

G_0 = typing.TypeVar("G_0")  # a
G_1 = typing.TypeVar("G_1")  # b
G_2 = typing.TypeVar("G_2")  # c
G_3 = typing.TypeVar("G_3")  # tStatus

PyTheorySentence = SenAttr[Sentence,ThmStatus[typing.Tuple[PyComorphism, PyBasicProof]]]
PyTheorySentenceByName = OMap[str,PyTheorySentence]
LinkPointer = typing.Tuple[LibName, LibEnv, LEdge[DGLinkLab]]
Sentence = GenericTransportType
SignatureJSON = GenericTransportType
SymbolJSON = GenericTransportType
TheoryPointer = typing.Tuple[LibName, LibEnv, DGraph, LNode[DGNodeLab]]
TheorySentence = SenAttr[Sentence,ThmStatus[typing.Tuple[AnyComorphism, BasicProof]]]
TheorySentenceByName = OMap[str,TheorySentence]

class PyTheory: ...
class PyProver: ...
class PyConsChecker: ...
class PyConservativityChecker: ...
class PyComorphism: ...
class PyProofTree: ...
class PyGMorphism: ...
class PyBasicProof:
    def __init__(self, x0: BasicProof): ...
class PyBasicProofGuessed(PyBasicProof): ...
class PyBasicProofConjectured(PyBasicProof): ...
class PyBasicProofHandwritten(PyBasicProof): ...
class PyProofOptions:
    def __init__(self, x0: Maybe[PyProver], x1: Maybe[PyComorphism], x2: bool, x3: typing.List[str], x4: typing.List[str], x5: int): ...
class PyConsCheckingOptions:
    def __init__(self, x0: Maybe[PyConsChecker], x1: Maybe[PyComorphism], x2: bool, x3: int): ...

def fstOf3(x0: typing.Tuple[G_0, G_1, G_2]) -> G_0: ...
def sndOf3(x0: typing.Tuple[G_0, G_1, G_2]) -> G_1: ...
def thd(x0: typing.Tuple[G_0, G_1, G_2]) -> G_2: ...
def pyProofStatusOfPyBasicProof(x0: PyBasicProof) -> Maybe[ProofStatus[PyProofTree]]: ...
def proofOptsProver(x0: PyProofOptions) -> Maybe[PyProver]: ...
def proofOptsComorphism(x0: PyProofOptions) -> Maybe[PyComorphism]: ...
def proofOptsUseTheorems(x0: PyProofOptions) -> bool: ...
def proofOptsGoalsToProve(x0: PyProofOptions) -> typing.List[str]: ...
def proofOptsAxiomsToInclude(x0: PyProofOptions) -> typing.List[str]: ...
def proofOptsTimeout(x0: PyProofOptions) -> int: ...
def mkPyProofOptions(x0: Maybe[PyProver], x1: Maybe[PyComorphism], x2: bool, x3: typing.List[str], x4: typing.List[str], x5: int) -> PyProofOptions: ...
def consOptsConsChecker(x0: PyConsCheckingOptions) -> Maybe[PyConsChecker]: ...
def consOptsComorphism(x0: PyConsCheckingOptions) -> Maybe[PyComorphism]: ...
def consOptsIncludeTheorems(x0: PyConsCheckingOptions) -> bool: ...
def consOptsTimeout(x0: PyConsCheckingOptions) -> int: ...
def defaultProofOptions() -> PyProofOptions: ...
def defaultConsCheckingOptions() -> PyConsCheckingOptions: ...
def proverName(x0: PyProver) -> str: ...
def comorphismName(x0: PyComorphism) -> str: ...
def targetLogicName(x0: PyComorphism) -> str: ...
def targetLogicDescriptionName(x0: PyComorphism) -> str: ...
def sourceLogicName(x0: PyComorphism) -> str: ...
def sourceLogicDescriptionName(x0: PyComorphism) -> str: ...
def consCheckerName(x0: PyConsChecker) -> str: ...
def conservativityCheckerName(x0: PyConservativityChecker) -> str: ...
def conservativityCheckerUsable(x0: PyConservativityChecker) -> IO[Maybe[str]]: ...
def theoryOfNode(x0: DGNodeLab) -> PyTheory: ...
def sublogicOfPyTheory(x0: PyTheory) -> str: ...
def getTheoryForSelection(x0: typing.List[str], x1: typing.List[str], x2: typing.List[str], x3: PyTheory) -> PyTheory: ...
def getUsableProvers(x0: PyTheory) -> IO[typing.List[typing.Tuple[PyProver, PyComorphism]]]: ...
def proveNode(x0: TheoryPointer, x1: PyProofOptions) -> IO[Result[typing.Tuple[PyTheory, typing.List[ProofStatus[PyProofTree]]]]]: ...
def recordProofResult(x0: TheoryPointer, x1: typing.Tuple[PyTheory, typing.List[ProofStatus[PyProofTree]]]) -> LibEnv: ...
def proveNodeAndRecord(x0: TheoryPointer, x1: PyProofOptions) -> IO[Result[typing.Tuple[typing.Tuple[PyTheory, typing.List[ProofStatus[PyProofTree]]], LibEnv]]]: ...
def translateTheory(x0: PyComorphism, x1: PyTheory) -> Result[PyTheory]: ...
def getAvailableComorphisms(x0: PyTheory) -> typing.List[PyComorphism]: ...
def getUsableConsistencyCheckers(x0: PyTheory) -> IO[typing.List[typing.Tuple[PyConsChecker, PyComorphism]]]: ...
def checkConsistency(x0: TheoryPointer, x1: PyConsCheckingOptions) -> IO[ConsistencyStatus]: ...
def checkConsistencyAndRecord(x0: TheoryPointer, x1: PyConsCheckingOptions) -> IO[typing.Tuple[ConsistencyStatus, LibEnv]]: ...
def getUsableConservativityCheckers(x0: LEdge[DGLinkLab], x1: LibEnv, x2: LibName) -> IO[typing.List[PyConservativityChecker]]: ...
def checkConservativityEdge(x0: PyConservativityChecker, x1: LinkPointer) -> IO[Result[typing.Tuple[Conservativity, PyTheory, PyTheory]]]: ...
def checkConservativityEdgeAndRecord(x0: PyConservativityChecker, x1: LinkPointer) -> IO[Result[typing.Tuple[typing.Tuple[Conservativity, PyTheory, PyTheory], LibEnv]]]: ...
def getAllSentences(x0: PyTheory) -> PyTheorySentenceByName: ...
def getAllAxioms(x0: PyTheory) -> PyTheorySentenceByName: ...
def getAllGoals(x0: PyTheory) -> PyTheorySentenceByName: ...
def getProvenGoals(x0: PyTheory) -> PyTheorySentenceByName: ...
def getUnprovenGoals(x0: PyTheory) -> PyTheorySentenceByName: ...
def theorySentenceBestProof(x0: PyTheorySentence) -> Maybe[PyBasicProof]: ...
def prettySentence(x0: PyTheory, x1: Sentence) -> str: ...
def signatureOfTheory(x0: PyTheory) -> ExtSign[SignatureJSON,SymbolJSON]: ...
def logicNameOfTheory(x0: PyTheory) -> str: ...
def logicDescriptionOfTheory(x0: PyTheory) -> str: ...
def getDGNodeById(x0: DGraph, x1: int) -> Maybe[DGNodeLab]: ...
def globalTheory(x0: DGNodeLab) -> Maybe[PyTheory]: ...
def gmorphismOfEdge(x0: DGLinkLab) -> PyGMorphism: ...
def comorphismOfGMorphism(x0: PyGMorphism) -> PyComorphism: ...
def signatureOfGMorphism(x0: PyGMorphism) -> ExtSign[SignatureJSON,SymbolJSON]: ...
def comorphismNameOfGMorphism(x0: PyGMorphism) -> str: ...
def comorphismDescriptionOfGMorphism(x0: PyGMorphism) -> str: ...
def domainOfGMorphism(x0: PyGMorphism) -> GenericTransportType: ...
def codomainOfGMorphism(x0: PyGMorphism) -> GenericTransportType: ...
def isGMorphismInclusion(x0: PyGMorphism) -> bool: ...
def gMorphismToTransportType(x0: PyGMorphism) -> GenericTransportType: ...
def automatic(x0: LibName, x1: LibEnv) -> LibEnv: ...
def automaticHideTheoremShift(x0: LibName, x1: LibEnv) -> LibEnv: ...
def compositionProveEdges(x0: LibName, x1: LibEnv) -> LibEnv: ...
def computeColimit(x0: LibName, x1: LibEnv) -> Result[LibEnv]: ...
def conservativity(x0: LibName, x1: LibEnv) -> LibEnv: ...
def freeness(x0: LibName, x1: LibEnv) -> Result[LibEnv]: ...
def getDevelopmentGraphNodeType(x0: DGNodeLab) -> DGNodeType: ...
def getEdgesFromDevelopmentGraph(x0: DGraph) -> typing.List[DGLinkLab]: ...
def getGraphForLibrary(x0: LibName, x1: LibEnv) -> DGraph: ...
def getLEdgesFromDevelopmentGraph(x0: DGraph) -> typing.List[LEdge[DGLinkLab]]: ...
def getLNodesFromDevelopmentGraph(x0: DGraph) -> typing.List[LNode[DGNodeLab]]: ...
def getLibraryDependencies(x0: LibEnv) -> typing.List[typing.Tuple[LibName, LibName]]: ...
def getNodesFromDevelopmentGraph(x0: DGraph) -> typing.List[DGNodeLab]: ...
def globalDecomposition(x0: LibName, x1: LibEnv) -> LibEnv: ...
def globalSubsume(x0: LibName, x1: LibEnv) -> LibEnv: ...
def libFlatDUnions(x0: LibName, x1: LibEnv) -> Result[LibEnv]: ...
def libFlatHeterogen(x0: LibName, x1: LibEnv) -> Result[LibEnv]: ...
def libFlatHiding(x0: LibName, x1: LibEnv) -> Result[LibEnv]: ...
def libFlatImports(x0: LibName, x1: LibEnv) -> Result[LibEnv]: ...
def libFlatRenamings(x0: LibName, x1: LibEnv) -> Result[LibEnv]: ...
def loadLibrary(x0: FilePath, x1: HetcatsOpts) -> IO[Result[typing.Tuple[LibName, LibEnv]]]: ...
def localDecomposition(x0: LibName, x1: LibEnv) -> LibEnv: ...
def localInference(x0: LibName, x1: LibEnv) -> LibEnv: ...
def normalForm(x0: LibName, x1: LibEnv) -> Result[LibEnv]: ...
def qualifyLibEnv(x0: LibName, x1: LibEnv) -> Result[LibEnv]: ...
def recomputeNode(x0: TheoryPointer) -> LibEnv: ...
def recordConservativityResult(x0: LinkPointer, x1: ConservativityResult) -> LibEnv: ...
def showTheory(x0: G_theory) -> str: ...
def theoremHideShift(x0: LibName, x1: LibEnv) -> Result[LibEnv]: ...
def theorySentenceContent(x0: SenAttr[G_0,ThmStatus[G_3]]) -> G_0: ...
def theorySentenceGetTheoremStatus(x0: SenAttr[G_0,ThmStatus[G_3]]) -> typing.List[G_3]: ...
def theorySentenceIsAxiom(x0: SenAttr[G_0,ThmStatus[G_3]]) -> bool: ...
def theorySentenceIsDefined(x0: SenAttr[G_0,ThmStatus[G_3]]) -> bool: ...
def theorySentencePriority(x0: SenAttr[G_0,ThmStatus[G_3]]) -> Maybe[str]: ...
def theorySentenceWasTheorem(x0: SenAttr[G_0,ThmStatus[G_3]]) -> bool: ...
def triangleCons(x0: LibName, x1: LibEnv) -> Result[LibEnv]: ...
